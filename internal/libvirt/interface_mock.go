// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package libvirt

import (
	"context"
	"sync"

	v1 "github.com/cobaltcore-dev/openstack-hypervisor-operator/api/v1"
	"github.com/digitalocean/go-libvirt"
)

// Ensure, that InterfaceMock does implement Interface.
// If this is not the case, regenerate this file with moq.
var _ Interface = &InterfaceMock{}

// InterfaceMock is a mock implementation of Interface.
//
//	func TestSomethingThatUsesInterface(t *testing.T) {
//
//		// make and configure a mocked Interface
//		mockedInterface := &InterfaceMock{
//			CloseFunc: func() error {
//				panic("mock out the Close method")
//			},
//			ConnectFunc: func() error {
//				panic("mock out the Connect method")
//			},
//			WatchDomainChangesFunc: func(eventId libvirt.DomainEventID, handlerId string, handler func(context.Context, any)) {
//				panic("mock out the WatchDomainChanges method")
//			},
//			ProcessFunc: func(hv v1.Hypervisor) (v1.Hypervisor, error) {
//				panic("mock out the Process method")
//			},
//		}
//
//		// use mockedInterface in code that requires Interface
//		// and then make assertions.
//
//	}
type InterfaceMock struct {
	// CloseFunc mocks the Close method.
	CloseFunc func() error

	// ConnectFunc mocks the Connect method.
	ConnectFunc func() error

	// WatchDomainChangesFunc mocks the WatchDomainChanges method.
	WatchDomainChangesFunc func(eventId libvirt.DomainEventID, handlerId string, handler func(context.Context, any))

	// ProcessFunc mocks the Process method.
	ProcessFunc func(hv v1.Hypervisor) (v1.Hypervisor, error)

	// calls tracks calls to the methods.
	calls struct {
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// Connect holds details about calls to the Connect method.
		Connect []struct {
		}
		// WatchDomainChanges holds details about calls to the WatchDomainChanges method.
		WatchDomainChanges []struct {
			EventId   libvirt.DomainEventID
			HandlerId string
			Handler   func(context.Context, any)
		}
		// Process holds details about calls to the Process method.
		Process []struct {
			Hv v1.Hypervisor
		}
	}
	lockClose              sync.RWMutex
	lockWatchDomainChanges sync.RWMutex
	lockConnect            sync.RWMutex
	lockProcess            sync.RWMutex
}

// Close calls CloseFunc.
func (mock *InterfaceMock) Close() error {
	if mock.CloseFunc == nil {
		panic("InterfaceMock.CloseFunc: method is nil but Interface.Close was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	return mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//
//	len(mockedInterface.CloseCalls())
func (mock *InterfaceMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// Connect calls ConnectFunc.
func (mock *InterfaceMock) Connect() error {
	if mock.ConnectFunc == nil {
		panic("InterfaceMock.ConnectFunc: method is nil but Interface.Connect was just called")
	}
	callInfo := struct {
	}{}
	mock.lockConnect.Lock()
	mock.calls.Connect = append(mock.calls.Connect, callInfo)
	mock.lockConnect.Unlock()
	return mock.ConnectFunc()
}

// ConnectCalls gets all the calls that were made to Connect.
// Check the length with:
//
//	len(mockedInterface.ConnectCalls())
func (mock *InterfaceMock) ConnectCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockConnect.RLock()
	calls = mock.calls.Connect
	mock.lockConnect.RUnlock()
	return calls
}

// WatchDomainChanges calls WatchDomainChangesFunc.
func (mock *InterfaceMock) WatchDomainChanges(eventId libvirt.DomainEventID, handlerId string, handler func(context.Context, any)) {
	if mock.WatchDomainChangesFunc == nil {
		panic("InterfaceMock.WatchDomainChangesFunc: method is nil but Interface.WatchDomainChanges was just called")
	}
	callInfo := struct {
		EventId   libvirt.DomainEventID
		HandlerId string
		Handler   func(context.Context, any)
	}{
		EventId:   eventId,
		HandlerId: handlerId,
		Handler:   handler,
	}
	mock.lockWatchDomainChanges.Lock()
	mock.calls.WatchDomainChanges = append(mock.calls.WatchDomainChanges, callInfo)
	mock.lockWatchDomainChanges.Unlock()
	mock.WatchDomainChangesFunc(eventId, handlerId, handler)
}

// WatchDomainChangesCalls gets all the calls that were made to WatchDomainChanges.
// Check the length with:
//
//	len(mockedInterface.WatchDomainChangesCalls())
func (mock *InterfaceMock) WatchDomainChangesCalls() []struct {
	EventId   libvirt.DomainEventID
	HandlerId string
	Handler   func(context.Context, any)
} {
	var calls []struct {
		EventId   libvirt.DomainEventID
		HandlerId string
		Handler   func(context.Context, any)
	}
	mock.lockWatchDomainChanges.RLock()
	calls = mock.calls.WatchDomainChanges
	mock.lockWatchDomainChanges.RUnlock()
	return calls
}

// Process calls ProcessFunc.
func (mock *InterfaceMock) Process(hv v1.Hypervisor) (v1.Hypervisor, error) {
	if mock.ProcessFunc == nil {
		panic("InterfaceMock.ProcessFunc: method is nil but Interface.Process was just called")
	}
	callInfo := struct {
		Hv v1.Hypervisor
	}{
		Hv: hv,
	}
	mock.lockProcess.Lock()
	mock.calls.Process = append(mock.calls.Process, callInfo)
	mock.lockProcess.Unlock()
	return mock.ProcessFunc(hv)
}

// ProcessCalls gets all the calls that were made to Process.
// Check the length with:
//
//	len(mockedInterface.ProcessCalls())
func (mock *InterfaceMock) ProcessCalls() []struct {
	Hv v1.Hypervisor
} {
	var calls []struct {
		Hv v1.Hypervisor
	}
	mock.lockProcess.RLock()
	calls = mock.calls.Process
	mock.lockProcess.RUnlock()
	return calls
}
